<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Bezier with Filled Crescents and Drag Mask</title>
  <style>
    html, body {margin:0; padding:0; height:100%; background:black; overflow:hidden;}
    canvas {display:block; cursor:default;}
    header {position:fixed; top:0; left:0; right:0; height:50px; background:#111; display:flex; align-items:center; padding:0 10px; z-index:10;}
    header button {margin-right:10px;}
    body > canvas {margin-top:50px;}
  </style>
</head>
<body>
<header>
  <button id="addElement">Add Element</button>
</header>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 50;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const steps = 16;
const connectorRadius = 20;
const lineWidth = 24;
let elements = [
  {x:200, y:200, rotation:0},
  {x:400, y:200, rotation:0}
];

let connections = [];
let drawingLine = false;
let lineStartEl = null;
let lineStartType = null;
let draggingEl = null;
let offsetX = 0;
let offsetY = 0;
canvas.mousePos = null;

function getConnectorPos(el, type){
  const r = 64 - connectorRadius; 
  const angle = (el.rotation / steps) * 2 * Math.PI;
  return type==='yellow'
    ? {x: el.x + r*Math.cos(angle), y: el.y + r*Math.sin(angle)}
    : {x: el.x - r*Math.cos(angle), y: el.y - r*Math.sin(angle)};
}

function connectionExists(aEl, aType, bEl, bType){
  return connections.some(c =>
    (c.startEl===aEl && c.startType===aType && c.endEl===bEl && c.endType===bType) ||
    (c.startEl===bEl && c.startType===bType && c.endEl===aEl && c.endType===aType)
  );
}

function drawCrescent(elX, elY, angle, outerR, color, clipR){
  const cx = elX + Math.cos(angle)*(64-connectorRadius);
  const cy = elY + Math.sin(angle)*(64-connectorRadius);
  ctx.save();
  if(!drawingLine){
    ctx.beginPath();
    ctx.arc(elX, elY, clipR, 0, Math.PI*2);
    ctx.clip();
  }
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(cx, cy, outerR, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const shootLength = 240;

  connections.forEach(c=>{
    const start = getConnectorPos(c.startEl, c.startType);
    const end = getConnectorPos(c.endEl, c.endType);
    const startDir = {x: start.x - c.startEl.x, y: start.y - c.startEl.y};
    const endDir = {x: end.x - c.endEl.x, y: end.y - c.endEl.y};
    const startLen = Math.hypot(startDir.x, startDir.y);
    const endLen = Math.hypot(endDir.x, endDir.y);
    const cp1 = {x: start.x + startDir.x/startLen*shootLength, y: start.y + startDir.y/startLen*shootLength};
    const cp2 = {x: end.x + endDir.x/endLen*shootLength, y: end.y + endDir.y/endLen*shootLength};

    ctx.strokeStyle='gray';
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
    ctx.stroke();
  });

  elements.forEach(el=>{
    ctx.fillStyle='rgba(30,150,200,0.35)';
    ctx.beginPath(); ctx.arc(el.x,el.y,64-connectorRadius,0,Math.PI*2); ctx.fill();
    drawCrescent(el.x, el.y, el.rotation/steps*2*Math.PI, connectorRadius, 'yellow', 64-connectorRadius);
    drawCrescent(el.x, el.y, Math.PI + el.rotation/steps*2*Math.PI, connectorRadius, 'green', 64-connectorRadius);
  });

  if(drawingLine && canvas.mousePos){
    const start = getConnectorPos(lineStartEl, lineStartType);
    const pos = canvas.mousePos;
    const startDir = {x: start.x - lineStartEl.x, y: start.y - lineStartEl.y};
    const startLen = Math.hypot(startDir.x, startDir.y);
    const cp1 = {x: start.x + startDir.x/startLen*shootLength, y: start.y + startDir.y/startLen*shootLength};
    const dx = pos.x - start.x, dy = pos.y - start.y;
    const cp2 = {x: start.x + dx/2, y: start.y + dy/2};

    ctx.strokeStyle='gray';
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.moveTo(start.x,start.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, pos.x,pos.y);
    ctx.stroke();
  }
}

// mouse events
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const pos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
  canvas.mousePos = pos;

  let overCircle = false;
  for(const el of elements){
    const yellow = getConnectorPos(el,'yellow');
    const green = getConnectorPos(el,'green');
    if((pos.x-yellow.x)**2 + (pos.y-yellow.y)**2 <= connectorRadius**2 || (pos.x-green.x)**2 + (pos.y-green.y)**2 <= connectorRadius**2){
      overCircle = true; break;
    }
  }

  if(!overCircle && draggingEl){
    draggingEl.x = pos.x - offsetX;
    draggingEl.y = pos.y - offsetY;
  }

  canvas.style.cursor = overCircle ? 'pointer' : (draggingEl ? 'grabbing' : 'default');
  draw();
});

canvas.addEventListener('mousedown', e=>{
  const rect = canvas.getBoundingClientRect();
  const pos = {x: e.clientX - rect.left, y: e.clientY - rect.top};

  for(const el of elements){
    const yellow = getConnectorPos(el,'yellow');
    const green = getConnectorPos(el,'green');
    if((pos.x-yellow.x)**2 + (pos.y-yellow.y)**2 <= connectorRadius**2){
      drawingLine = true; lineStartEl = el; lineStartType = 'yellow'; return;
    }
    if((pos.x-green.x)**2 + (pos.y-green.y)**2 <= connectorRadius**2){
      drawingLine = true; lineStartEl = el; lineStartType = 'green'; return;
    }
  }

  for(const el of elements){
    const dx = pos.x - el.x, dy = pos.y - el.y;
    if(dx*dx + dy*dy <= (64-connectorRadius)**2){
      draggingEl = el;
      offsetX = dx;
      offsetY = dy;
      return;
    }
  }
});

canvas.addEventListener('mouseup', e=>{
  const rect = canvas.getBoundingClientRect();
  const pos = {x: e.clientX - rect.left, y: e.clientY - rect.top};

  if(drawingLine){
    for(const el of elements){
      if(el === lineStartEl) continue;
      const connectors = [{type:'yellow', pos:getConnectorPos(el,'yellow')},{type:'green', pos:getConnectorPos(el,'green')}];
      for(const c of connectors){
        if((pos.x-c.pos.x)**2 + (pos.y-c.pos.y)**2 <= connectorRadius**2){
          if(!connectionExists(lineStartEl, lineStartType, el, c.type)){
            connections.push({startEl:lineStartEl,startType:lineStartType,endEl:el,endType:c.type});
          }
          break;
        }
      }
    }
  }

  drawingLine = false; lineStartEl = null; lineStartType = null;
  draggingEl = null;
  canvas.mousePos = null;
  draw();
});

canvas.addEventListener('mouseleave', ()=>{drawingLine = false; lineStartEl=null; lineStartType=null; draggingEl=null; canvas.mousePos=null; draw();});

canvas.addEventListener('wheel', e=>{
  const rect = canvas.getBoundingClientRect();
  const pos = {x: e.clientX - rect.left, y: e.clientY - rect.top};
  for(const el of elements){
    const dx = pos.x - el.x, dy = pos.y - el.y;
    if(dx*dx + dy*dy <= (64-connectorRadius)**2){
      el.rotation += (e.deltaY>0?1:-1);
      if(el.rotation<0) el.rotation += steps;
      if(el.rotation>=steps) el.rotation -= steps;
      break;
    }
  }
  draw();
});

// add element button
document.getElementById('addElement').addEventListener('click', ()=>{
  elements.push({x:100+Math.random()*400, y:100+Math.random()*300, rotation:0});
  draw();
});

draw();
</script>
</body>
</html>
