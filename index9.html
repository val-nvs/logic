<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Simplified Bezier Editor</title>
  <style>
    html, body {margin:0; padding:0; height:100%; background:black; overflow:hidden;}
    canvas {display:block; cursor:default; margin-top:50px;}
    header {position:fixed; top:0; left:0; right:0; height:50px; background:#111; display:flex; align-items:center; padding:0 10px; z-index:10;}
    header button {margin-right:10px; padding:5px 10px; background:#333; color:white; border:none; cursor:pointer;}
    header button:hover {background:#444;}
  </style>
</head>
<body>
<header>
  <button id="addNotNor">Add Not/Nor</button>
  <button id="addLED">Add LED</button>
  <button id="addSwitch">Add Switch</button>
  <button id="exportJSON">Export JSON</button>
</header>
<canvas id="c"></canvas>
<script>
// Configuration constants
const CONFIG = {
  steps: 16,
  connectorRadius: 20,
  lineWidth: 24,
  elementRadius: 64,
  shootLength: 100,
  gridSpacing: 40,
  tolerance: 15,
  zoomFactor: 0.1,
  minScale: 0.2,
  maxScale: 3,
  doubleClickTime: 300 // ms
};

// Element types configuration
const ELEMENT_TYPES = {
  'not/nor': {
    hasYellow: true,
    hasGreen: true,
    color: 'rgba(30,150,200,0.35)',
    label: 'NOT/NOR'
  },
  'LED': {
    hasYellow: false,
    hasGreen: true,
    color: 'rgba(255,100,100,0.35)',
    label: 'LED'
  },
  'SWITCH': {
    hasYellow: true,
    hasGreen: false,
    color: 'rgba(100,255,100,0.35)',
    activeColor: 'rgba(150,255,150,0.6)',
    label: 'SWITCH'
  }
};

// App state
const state = {
  elements: [
    {x:200, y:200, rotation:0, type:'not/nor'}, 
    {x:400, y:200, rotation:0, type:'not/nor'}
  ],
  connections: [],
  drawing: {active: false, startEl: null, startType: null},
  dragging: {element: null, background: false, offsetX: 0, offsetY: 0},
  transform: {scale: 1, offset: {x:0, y:0}},
  mouse: {pos: null, dragStart: {x:0, y:0}, offsetStart: {x:0, y:0}},
  lastClick: {time: 0, target: null}
};

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 50;
}

// Coordinate transformation utilities
const transform = {
  screenToWorld: (x, y) => ({
    x: (x - state.transform.offset.x) / state.transform.scale, 
    y: (y - state.transform.offset.y) / state.transform.scale
  }),
  worldToScreen: (x, y) => ({
    x: x * state.transform.scale + state.transform.offset.x, 
    y: y * state.transform.scale + state.transform.offset.y
  })
};

// Geometry utilities
const geometry = {
  distance: (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y),
  
  isPointInCircle: (point, center, radius) => 
    geometry.distance(point, center) <= radius,
  
  getConnectorPos: (el, type) => {
    const r = CONFIG.elementRadius - CONFIG.connectorRadius;
    const angle = (el.rotation / CONFIG.steps) * 2 * Math.PI;
    const multiplier = type === 'yellow' ? 1 : -1;
    return {
      x: el.x + multiplier * r * Math.cos(angle), 
      y: el.y + multiplier * r * Math.sin(angle)
    };
  },
  
  getBezierPoint: (t, start, cp1, cp2, end) => ({
    x: (1-t)**3 * start.x + 3*(1-t)**2*t * cp1.x + 3*(1-t)*t**2 * cp2.x + t**3 * end.x,
    y: (1-t)**3 * start.y + 3*(1-t)**2*t * cp1.y + 3*(1-t)*t**2 * cp2.y + t**3 * end.y
  }),
  
  isPointOnBezier: (point, start, cp1, cp2, end) => {
    for (let t = 0; t <= 1; t += 0.05) {
      const bezierPoint = geometry.getBezierPoint(t, start, cp1, cp2, end);
      if (geometry.distance(point, bezierPoint) <= CONFIG.tolerance) return true;
    }
    return false;
  }
};

// Connection utilities
const connections = {
  exists: (aEl, aType, bEl, bType) => 
    state.connections.some(c =>
      (c.startEl===aEl && c.startType===aType && c.endEl===bEl && c.endType===bType) ||
      (c.startEl===bEl && c.startType===bType && c.endEl===aEl && c.endType===aType)
    ),
  
  add: (startEl, startType, endEl, endType) => {
    // Don't allow connections to same element
    if (startEl === endEl) return;
    
    if (!connections.exists(startEl, startType, endEl, endType)) {
      state.connections.push({startEl, startType, endEl, endType});
    }
  },
  
  remove: (connection) => {
    const index = state.connections.indexOf(connection);
    if (index > -1) {
      state.connections.splice(index, 1);
    }
  },
  
  removeByElement: (element) => {
    state.connections = state.connections.filter(c => 
      c.startEl !== element && c.endEl !== element
    );
  },
  
  getUnderMouse: (worldPos) => {
    for (const c of state.connections) {
      const start = geometry.getConnectorPos(c.startEl, c.startType);
      const end = geometry.getConnectorPos(c.endEl, c.endType);
      const {cp1, cp2} = connections.getControlPoints(c, start, end);
      
      if (geometry.isPointOnBezier(worldPos, start, cp1, cp2, end)) return c;
    }
    return null;
  },
  
  getControlPoints: (connection, start, end) => {
    const startDir = {x: start.x - connection.startEl.x, y: start.y - connection.startEl.y};
    const endDir = {x: end.x - connection.endEl.x, y: end.y - connection.endEl.y};
    const startLen = Math.hypot(startDir.x, startDir.y);
    const endLen = Math.hypot(endDir.x, endDir.y);
    
    const startShoot = connection.startShootLength || CONFIG.shootLength;
    const endShoot = connection.endShootLength || CONFIG.shootLength;
    
    return {
      cp1: {x: start.x + startDir.x/startLen*startShoot, y: start.y + startDir.y/startLen*startShoot},
      cp2: {x: end.x + endDir.x/endLen*endShoot, y: end.y + endDir.y/endLen*endShoot}
    };
  }
};

// Drawing functions
const drawing = {
  background: () => {
    ctx.fillStyle = "#222";
    const {scale, offset} = state.transform;
    
    // Calculate visible world bounds
    const worldLeft = -offset.x / scale;
    const worldTop = -offset.y / scale;
    const worldRight = worldLeft + canvas.width / scale;
    const worldBottom = worldTop + canvas.height / scale;
    
    // Find the grid bounds that cover the visible area
    const gridLeft = Math.floor(worldLeft / CONFIG.gridSpacing) * CONFIG.gridSpacing;
    const gridTop = Math.floor(worldTop / CONFIG.gridSpacing) * CONFIG.gridSpacing;
    
    // Draw grid dots
    for(let x = gridLeft; x <= worldRight; x += CONFIG.gridSpacing) {
      for(let y = gridTop; y <= worldBottom; y += CONFIG.gridSpacing) {
        ctx.beginPath();
        ctx.arc(x, y, 1.5 / scale, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  },
  
  crescent: (elX, elY, angle, outerR, color, clipR) => {
    const cx = elX + Math.cos(angle)*(CONFIG.elementRadius-CONFIG.connectorRadius);
    const cy = elY + Math.sin(angle)*(CONFIG.elementRadius-CONFIG.connectorRadius);
    ctx.save();
    if(!state.drawing.active){
      ctx.beginPath();
      ctx.arc(elX, elY, clipR, 0, Math.PI*2);
      ctx.clip();
    }
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(cx, cy, outerR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  },
  
  connections: () => {
    state.connections.forEach(c => {
      const start = geometry.getConnectorPos(c.startEl, c.startType);
      const end = geometry.getConnectorPos(c.endEl, c.endType);
      const {cp1, cp2} = connections.getControlPoints(c, start, end);

      // Check if connection involves an active switch
      const isActive = (c.startEl.type === 'SWITCH' && c.startEl.active) || 
                      (c.endEl.type === 'SWITCH' && c.endEl.active);
      
      ctx.strokeStyle = isActive ? 'rgba(255,255,128,0.7)' : 'rgba(128,128,128,0.6)';
      ctx.lineWidth = CONFIG.lineWidth;
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
      ctx.stroke();
    });
  },
  
  elements: () => {
    state.elements.forEach(el => {
      const radius = CONFIG.elementRadius - CONFIG.connectorRadius;
      const typeConfig = ELEMENT_TYPES[el.type];
      
      // Main circle with type-specific color
      let fillColor = typeConfig.color;
      if (el.type === 'SWITCH' && el.active) {
        fillColor = typeConfig.activeColor;
      }
      
      ctx.fillStyle = fillColor;
      ctx.beginPath();
      ctx.arc(el.x, el.y, radius, 0, Math.PI*2);
      ctx.fill();
      
      // Draw type label
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = `${12/state.transform.scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      let label = typeConfig.label;
      if (el.type === 'SWITCH') {
        label += el.active ? ' ON' : ' OFF';
      }
      ctx.fillText(label, el.x, el.y);
      ctx.restore();
      
      // Draw connectors based on type
      const angle = el.rotation / CONFIG.steps * 2 * Math.PI;
      if (typeConfig.hasYellow) {
        const yellowColor = el.type === 'SWITCH' && el.active ? 
          'rgba(255,255,100,1)' : 'rgba(255,255,0,0.8)';
        drawing.crescent(el.x, el.y, angle, CONFIG.connectorRadius, yellowColor, radius);
      }
      if (typeConfig.hasGreen) {
        drawing.crescent(el.x, el.y, Math.PI + angle, CONFIG.connectorRadius, 'rgba(0,255,0,0.8)', radius);
      }
    });
  },
  
  currentLine: () => {
    if (!state.drawing.active || !state.mouse.pos) return;
    
    const start = geometry.getConnectorPos(state.drawing.startEl, state.drawing.startType);
    const mouseWorld = transform.screenToWorld(state.mouse.pos.x, state.mouse.pos.y);
    const startDir = {x: start.x - state.drawing.startEl.x, y: start.y - state.drawing.startEl.y};
    const startLen = Math.hypot(startDir.x, startDir.y);
    const cp1 = {x: start.x + startDir.x/startLen*CONFIG.shootLength, y: start.y + startDir.y/startLen*CONFIG.shootLength};
    const dx = mouseWorld.x - start.x, dy = mouseWorld.y - start.y;
    const cp2 = {x: start.x + dx/2, y: start.y + dy/2};

    ctx.strokeStyle = 'rgba(128,128,128,0.8)';
    ctx.lineWidth = CONFIG.lineWidth;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, mouseWorld.x, mouseWorld.y);
    ctx.stroke();
  }
};

function draw() {
  const {scale, offset} = state.transform;
  ctx.setTransform(scale, 0, 0, scale, offset.x, offset.y);
  ctx.clearRect(-offset.x/scale, -offset.y/scale, canvas.width/scale, canvas.height/scale);
  
  drawing.background();
  drawing.connections();
  drawing.elements();
  drawing.currentLine();
}

// Input handling
const input = {
  getMousePos: (e) => {
    const rect = canvas.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  },
  
  getElementUnderMouse: (worldPos) => {
    const radius = CONFIG.elementRadius - CONFIG.connectorRadius;
    return state.elements.find(el => geometry.isPointInCircle(worldPos, el, radius));
  },
  
  getConnectorUnderMouse: (worldPos) => {
    for (const el of state.elements) {
      const typeConfig = ELEMENT_TYPES[el.type];
      
      if (typeConfig.hasYellow) {
        const yellow = geometry.getConnectorPos(el, 'yellow');
        if (geometry.isPointInCircle(worldPos, yellow, CONFIG.connectorRadius)) {
          return {el, type: 'yellow'};
        }
      }
      
      if (typeConfig.hasGreen) {
        const green = geometry.getConnectorPos(el, 'green');
        if (geometry.isPointInCircle(worldPos, green, CONFIG.connectorRadius)) {
          return {el, type: 'green'};
        }
      }
    }
    return null;
  },
  
  getCursor: (worldPos) => {
    const connector = input.getConnectorUnderMouse(worldPos);
    if (connector) return 'pointer';
    
    const element = input.getElementUnderMouse(worldPos);
    if (element) {
      if (element.type === 'SWITCH') return 'pointer';
      return 'default';
    }
    
    const connection = connections.getUnderMouse(worldPos);
    if (connection) return 'ew-resize';
    
    if (state.dragging.element) return 'grabbing';
    if (state.dragging.background) return 'grabbing';
    
    return 'default';
  }
};

// Event handlers
canvas.addEventListener('mousemove', e => {
  const pos = input.getMousePos(e);
  state.mouse.pos = pos;
  const worldPos = transform.screenToWorld(pos.x, pos.y);

  if (state.dragging.background) {
    state.transform.offset.x = state.mouse.offsetStart.x + (pos.x - state.mouse.dragStart.x);
    state.transform.offset.y = state.mouse.offsetStart.y + (pos.y - state.mouse.dragStart.y);
    draw();
    return;
  }

  if (state.dragging.element) {
    state.dragging.element.x = worldPos.x - state.dragging.offsetX;
    state.dragging.element.y = worldPos.y - state.dragging.offsetY;
  }

  canvas.style.cursor = input.getCursor(worldPos);
  draw();
});

canvas.addEventListener('mousedown', e => {
  const pos = input.getMousePos(e);
  const worldPos = transform.screenToWorld(pos.x, pos.y);
  const currentTime = Date.now();
  
  // Check for double click
  const isDoubleClick = currentTime - state.lastClick.time < CONFIG.doubleClickTime;
  
  // Handle double click on connections
  const connection = connections.getUnderMouse(worldPos);
  if (connection && isDoubleClick) {
    connections.remove(connection);
    draw();
    return;
  }
  
  // Handle double click on elements
  const element = input.getElementUnderMouse(worldPos);
  if (element && isDoubleClick && state.lastClick.target === element) {
    connections.removeByElement(element);
    const index = state.elements.indexOf(element);
    if (index > -1) {
      state.elements.splice(index, 1);
    }
    draw();
    return;
  }
  
  // Update last click info
  state.lastClick.time = currentTime;
  state.lastClick.target = element;
  
  // Single click on switch toggles it
  if (element && element.type === 'SWITCH' && !isDoubleClick) {
    const connector = input.getConnectorUnderMouse(worldPos);
    if (!connector) {
      element.active = !element.active;
      draw();
      return;
    }
  }
  
  // Check connectors
  const connector = input.getConnectorUnderMouse(worldPos);
  if (connector) {
    state.drawing.active = true;
    state.drawing.startEl = connector.el;
    state.drawing.startType = connector.type;
    return;
  }
  
  // Drag element
  if (element) {
    state.dragging.element = element;
    state.dragging.offsetX = worldPos.x - element.x;
    state.dragging.offsetY = worldPos.y - element.y;
    return;
  }
  
  // Background drag
  state.dragging.background = true;
  state.mouse.dragStart = pos;
  state.mouse.offsetStart = {...state.transform.offset};
});

canvas.addEventListener('mouseup', e => {
  if (state.dragging.background) {
    state.dragging.background = false;
  }

  if (state.drawing.active) {
    const pos = input.getMousePos(e);
    const worldPos = transform.screenToWorld(pos.x, pos.y);
    const connector = input.getConnectorUnderMouse(worldPos);
    
    if (connector) {
      connections.add(state.drawing.startEl, state.drawing.startType, connector.el, connector.type);
    }
  }

  // Reset all interaction states
  Object.assign(state.drawing, {active: false, startEl: null, startType: null});
  Object.assign(state.dragging, {element: null, background: false, offsetX: 0, offsetY: 0});
  state.mouse.pos = null;
  draw();
});

canvas.addEventListener('mouseleave', () => {
  Object.assign(state.drawing, {active: false, startEl: null, startType: null});
  Object.assign(state.dragging, {element: null, background: false});
  state.mouse.pos = null;
  draw();
});

canvas.addEventListener('wheel', e => {
  const pos = input.getMousePos(e);
  const worldPos = transform.screenToWorld(pos.x, pos.y);
  
  // Element rotation
  const element = input.getElementUnderMouse(worldPos);
  if (element) {
    element.rotation += e.deltaY > 0 ? 1 : -1;
    if (element.rotation < 0) element.rotation += CONFIG.steps;
    if (element.rotation >= CONFIG.steps) element.rotation -= CONFIG.steps;
  }
  // Bezier curve adjustment
  else {
    const connection = connections.getUnderMouse(worldPos);
    if (connection) {
      const delta = e.deltaY > 0 ? -20 : 20;
      connection.startShootLength = Math.max(20, Math.min(500, (connection.startShootLength || CONFIG.shootLength) + delta));
      connection.endShootLength = Math.max(20, Math.min(500, (connection.endShootLength || CONFIG.shootLength) + delta));
    }
    // Zoom
    else {
      const factor = e.deltaY > 0 ? (1 - CONFIG.zoomFactor) : (1 + CONFIG.zoomFactor);
      const worldBefore = worldPos;
      
      state.transform.scale = Math.max(CONFIG.minScale, Math.min(CONFIG.maxScale, state.transform.scale * factor));
      
      const worldAfter = transform.screenToWorld(pos.x, pos.y);
      state.transform.offset.x += (worldAfter.x - worldBefore.x) * state.transform.scale;
      state.transform.offset.y += (worldAfter.y - worldBefore.y) * state.transform.scale;
    }
  }

  draw();
  e.preventDefault();
});

// UI handlers
function addElement(type) {
  const element = {
    x: 100 + Math.random() * 400, 
    y: 100 + Math.random() * 300, 
    rotation: 0,
    type: type
  };
  
  // Switches start in off state
  if (type === 'SWITCH') {
    element.active = false;
  }
  
  state.elements.push(element);
  draw();
}

document.getElementById('addNotNor').addEventListener('click', () => addElement('not/nor'));
document.getElementById('addLED').addEventListener('click', () => addElement('LED'));
document.getElementById('addSwitch').addEventListener('click', () => addElement('SWITCH'));

document.getElementById('exportJSON').addEventListener('click', () => {
  const data = {
    elements: state.elements.map(el => {
      const obj = {
        x: el.x, 
        y: el.y, 
        rotation: el.rotation,
        type: el.type
      };
      if (el.type === 'SWITCH') {
        obj.active = el.active;
      }
      return obj;
    }),
    connections: state.connections.map(c => ({
      startIndex: state.elements.indexOf(c.startEl), 
      startType: c.startType, 
      endIndex: state.elements.indexOf(c.endEl), 
      endType: c.endType,
      startShootLength: c.startShootLength,
      endShootLength: c.endShootLength
    }))
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), {
    href: url,
    download: 'layout.json'
  });
  a.click();
  URL.revokeObjectURL(url);
});

// Initialize
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
draw();
</script>
</body>
</html>